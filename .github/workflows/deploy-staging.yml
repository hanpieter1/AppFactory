# Deploy to Staging Environment
# INFRA-003: Staging Environment with Manual Deploy Trigger
#
# This workflow allows deploying any branch to the staging environment
# for testing before creating a PR to main.
#
# Usage:
#   1. Go to Actions tab in GitHub
#   2. Select "Deploy to Staging" workflow
#   3. Click "Run workflow"
#   4. Select branch to deploy
#   5. Click "Run workflow"

name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy to staging'
        required: true
        default: 'main'
        type: string
      skip_tests:
        description: 'Skip tests (faster deployment)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: eu-central-1
  ECR_REPOSITORY: appfactory-app

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging

    # Required secrets:
    # - AWS_ACCESS_KEY_ID
    # - AWS_SECRET_ACCESS_KEY
    # - APP_RUNNER_STAGING_SERVICE_ARN (staging service ARN)

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      - name: Display deployment info
        env:
          DEPLOY_BRANCH: ${{ inputs.branch }}
          DEPLOY_SHA: ${{ github.sha }}
          DEPLOY_ACTOR: ${{ github.actor }}
          DEPLOY_SKIP_TESTS: ${{ inputs.skip_tests }}
        run: |
          echo "## Staging Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: $DEPLOY_BRANCH" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: $DEPLOY_SHA" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: $DEPLOY_ACTOR" >> $GITHUB_STEP_SUMMARY
          echo "- **Skip tests**: $DEPLOY_SKIP_TESTS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run tests
        if: ${{ !inputs.skip_tests }}
        run: npm test

      - name: Build application
        run: npm run build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tag
        id: image-tag
        env:
          INPUT_BRANCH: ${{ inputs.branch }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Create a staging-specific tag with branch name and short SHA
          BRANCH_SLUG=$(echo "$INPUT_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g' | cut -c1-20)
          SHORT_SHA=$(echo "$COMMIT_SHA" | cut -c1-7)
          TAG="staging-${BRANCH_SLUG}-${SHORT_SHA}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $TAG"

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
        run: |
          # Build and push Docker image with staging tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:staging
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:staging

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Pushed images:"
          echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "  - $ECR_REGISTRY/$ECR_REPOSITORY:staging"

      - name: Check if staging service exists
        id: check-service
        env:
          SERVICE_ARN: ${{ secrets.APP_RUNNER_STAGING_SERVICE_ARN }}
        run: |
          if [ -z "$SERVICE_ARN" ]; then
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::warning::APP_RUNNER_STAGING_SERVICE_ARN secret not set. Please create the staging service first."
          else
            echo "exists=true" >> $GITHUB_OUTPUT
          fi

      - name: Resume staging service if paused
        if: steps.check-service.outputs.exists == 'true'
        env:
          SERVICE_ARN: ${{ secrets.APP_RUNNER_STAGING_SERVICE_ARN }}
        run: |
          echo "Checking staging service status..."
          STATUS=$(aws apprunner describe-service \
            --service-arn "$SERVICE_ARN" \
            --region "$AWS_REGION" \
            --query 'Service.Status' \
            --output text)

          echo "Current status: $STATUS"

          if [[ "$STATUS" == "PAUSED" ]]; then
            echo "Service is paused, resuming..."
            aws apprunner resume-service \
              --service-arn "$SERVICE_ARN" \
              --region "$AWS_REGION"
            echo "Resume command sent"
          fi

      - name: Wait for staging service to be ready
        if: steps.check-service.outputs.exists == 'true'
        env:
          SERVICE_ARN: ${{ secrets.APP_RUNNER_STAGING_SERVICE_ARN }}
        run: |
          echo "Waiting for staging service to be in RUNNING state..."
          for i in {1..60}; do
            STATUS=$(aws apprunner describe-service \
              --service-arn "$SERVICE_ARN" \
              --region "$AWS_REGION" \
              --query 'Service.Status' \
              --output text)

            echo "Attempt $i/60: Service status = $STATUS"

            if [[ "$STATUS" == "RUNNING" ]]; then
              echo "Staging service is ready"
              break
            fi

            if [[ $i -eq 60 ]]; then
              echo "Timeout waiting for staging service"
              exit 1
            fi

            sleep 10
          done

      - name: Deploy to Staging App Runner
        if: steps.check-service.outputs.exists == 'true'
        env:
          SERVICE_ARN: ${{ secrets.APP_RUNNER_STAGING_SERVICE_ARN }}
        run: |
          aws apprunner start-deployment \
            --service-arn "$SERVICE_ARN" \
            --region "$AWS_REGION"

          echo "Deployment triggered for staging service"

      - name: Wait for deployment
        if: steps.check-service.outputs.exists == 'true'
        env:
          SERVICE_ARN: ${{ secrets.APP_RUNNER_STAGING_SERVICE_ARN }}
        run: |
          echo "Waiting for deployment to complete..."
          sleep 30

          STATUS=$(aws apprunner describe-service \
            --service-arn "$SERVICE_ARN" \
            --region "$AWS_REGION" \
            --query 'Service.Status' \
            --output text)

          echo "Staging service status: $STATUS"

      - name: Get Staging URL
        if: steps.check-service.outputs.exists == 'true'
        id: get-url
        env:
          SERVICE_ARN: ${{ secrets.APP_RUNNER_STAGING_SERVICE_ARN }}
        run: |
          SERVICE_URL=$(aws apprunner describe-service \
            --service-arn "$SERVICE_ARN" \
            --region "$AWS_REGION" \
            --query 'Service.ServiceUrl' \
            --output text)

          echo "url=https://$SERVICE_URL" >> $GITHUB_OUTPUT
          echo "Staging URL: https://$SERVICE_URL"

      - name: Smoke test - Health endpoint
        if: steps.check-service.outputs.exists == 'true'
        env:
          STAGING_URL: ${{ steps.get-url.outputs.url }}
        run: |
          URL="$STAGING_URL/health"
          echo "Testing health endpoint: $URL"

          for i in {1..5}; do
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || echo "000")

            if [[ "$RESPONSE" == "200" ]]; then
              echo "Health check passed (HTTP $RESPONSE)"
              exit 0
            fi

            echo "Attempt $i/5: HTTP $RESPONSE, retrying..."
            sleep 10
          done

          echo "Health check failed after 5 attempts"
          exit 1

      - name: Deployment summary
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          BUILD_IMAGE: ${{ steps.build-image.outputs.image }}
          SERVICE_EXISTS: ${{ steps.check-service.outputs.exists }}
          STAGING_URL: ${{ steps.get-url.outputs.url }}
          DEPLOY_BRANCH: ${{ inputs.branch }}
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: $JOB_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: $BUILD_IMAGE" >> $GITHUB_STEP_SUMMARY
          if [ "$SERVICE_EXISTS" == "true" ]; then
            echo "- **Staging URL**: $STAGING_URL" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Quick Links" >> $GITHUB_STEP_SUMMARY
            echo "- [Health Check]($STAGING_URL/health)" >> $GITHUB_STEP_SUMMARY
            echo "- [Status API]($STAGING_URL/api/status)" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Setup Required" >> $GITHUB_STEP_SUMMARY
            echo "The staging App Runner service needs to be created. See issue #46 for instructions." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Deployed from branch: $DEPLOY_BRANCH*" >> $GITHUB_STEP_SUMMARY
